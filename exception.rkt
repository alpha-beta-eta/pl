#lang racket
(require "match.rkt" "env0.rkt" "truep.rkt")
;<exp> ::= <int>
;       |  <bool>
;       |  <str>
;       |  <var>
;       |  (if <exp> <exp> <exp>)
;       |  (lambda <var> <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (raise <exp>)
;       |  (try <exp> catch <var> <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>)
;<op> ::= + | - | * | = | string=?
(define (interp exp env k)
  (match exp
    (,int
     (guard (integer? int))
     (apply-k k int))
    (,bool
     (guard (boolean? bool))
     (apply-k k bool))
    (,str
     (guard (string? str))
     (apply-k k str))
    (,var
     (guard (symbol? var))
     (apply-k k (apply-env env var)))
    ((if ,e1 ,e2 ,e3)
     (interp e1 env (if-k e2 e3 env k)))
    ((lambda ,x ,body)
     (apply-k k (make-closure x body env)))
    ((let ,x ,e ,body)
     (interp e env (let-k x env body k)))
    ((raise ,e)
     (interp e env (raise-k k)))
    ((try ,e1 catch ,x ,e2)
     (interp e1 env (try-k x e2 env k)))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * = string=?)))
     (interp e1 env (op-k-1 op e2 env k)))
    ((,rator ,rand)
     (interp rator env (rator-k rand env k)))))
(define (make-closure formal body env)
  (vector 'closure formal body env))
(define (closure-formal closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (apply-closure closure arg k)
  (let* ((formal (closure-formal closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (interp body (extend-env formal arg env) k)))
(define (apply-k k v)
  (match k
    ((if-k ,e2 ,e3 ,env ,k)
     (if (true? v)
         (interp e2 env k)
         (interp e3 env k)))
    ((let-k ,x ,env ,body ,k)
     (interp body (extend-env x v env) k))
    ((raise-k ,k)
     (apply-handler k v))
    ((try-k ,x ,e2 ,env ,k)
     (apply-k k v))
    ((op-k-1 ,op ,e2 ,env ,k)
     (interp e2 env (op-k-2 op v k)))
    ((op-k-2 ,op ,v1 ,k)
     (case op
       ((+) (apply-k k (+ v1 v)))
       ((-) (apply-k k (- v1 v)))
       ((*) (apply-k k (* v1 v)))
       ((=) (apply-k k (= v1 v)))
       ((string=?) (apply-k k (string=? v1 v)))))
    ((rator-k ,rand ,env ,k)
     (interp rand env (rand-k v k)))
    ((rand-k ,closure ,k)
     (apply-closure closure v k))
    ((empty-k) v)))
(define (apply-handler k v)
  (match k
    ((if-k ,e2 ,e3 ,env ,k)
     (apply-handler k v))
    ((let-k ,x ,env ,body ,k)
     (apply-handler k v))
    ((raise-k ,k)
     (apply-handler k v))
    ((try-k ,x ,e2 ,env ,k)
     (interp e2 (extend-env x v env) k))
    ((op-k-1 ,op ,e2 ,env ,k)
     (apply-handler k v))
    ((op-k-2 ,op ,v1 ,k)
     (apply-handler k v))
    ((rator-k ,rand ,env ,k)
     (apply-handler k v))
    ((rand-k ,closure ,k)
     (apply-handler k v))
    ((empty-k)
     (error 'apply-handler "unhandled exception ~s" v))))
(define (empty-k) '(empty-k))
(define (if-k e2 e3 env k)
  `(if-k ,e2 ,e3 ,env ,k))
(define (let-k x env body k)
  `(let-k ,x ,env ,body ,k))
(define (raise-k k)
  `(raise-k ,k))
(define (try-k x e2 env k)
  `(try-k ,x ,e2 ,env ,k))
(define (op-k-1 op e2 env k)
  `(op-k-1 ,op ,e2 ,env ,k))
(define (op-k-2 op v1 k)
  `(op-k-2 ,op ,v1 ,k))
(define (rator-k rand env k)
  `(rator-k ,rand ,env ,k))
(define (rand-k closure k)
  `(rand-k ,closure ,k))
;> (interp '(try (try (try (raise "foo")
;                          catch x
;                          (raise "bar"))
;                     catch y
;                     (raise "baz"))
;                catch z z)
;          (empty-env)
;          (empty-k))
;"baz"
;> (interp '(let foobar (lambda str
;                         (if (string=? str "foo")
;                             (raise "foo")
;                             (if (string=? str "bar")
;                                 (raise "bar")
;                                 (raise "baz"))))
;             (try (foobar "foobar")
;                  catch x
;                  (if (string=? x "foo")
;                      1
;                      (if (string=? x "bar")
;                          2
;                          (if (string=? x "baz")
;                              3
;                              0)))))
;          (empty-env)
;          (empty-k))
;3