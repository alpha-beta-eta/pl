#lang racket
(require "match.rkt" "env0.rkt" "truep.rkt")
;<exp> ::= <int>
;       |  <bool>
;       |  <var>
;       |  (if <exp> <exp> <exp>)
;       |  (lambda (<var>*) <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (letrec ((<var> (lambda (<var>*) <exp>))*) <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>*)
;<op> ::= + | - | * | =
(define (interp exp env)
  (match exp
    (,int (guard (integer? int)) int)
    (,bool (guard (boolean? bool)) bool)
    (,var (guard (symbol? var)) (apply-env env var))
    ((if ,e1 ,e2 ,e3)
     (let ((v1 (interp e1 env)))
       (if (true? v1)
           (interp e2 env)
           (interp e3 env))))
    ((lambda ,x* ,body)
     (make-closure x* body env))
    ((let ,x ,e ,body)
     (let* ((v (interp e env))
            (env^ (extend-env x v env)))
       (interp body env^)))
    ((letrec ,binding* ,body)
     (let-values (((f* x** fbody*) (decompose binding*)))
       (interp body (extend-env-rec f* x** fbody* env))))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * =)))
     (let* ((v1 (interp e1 env))
            (v2 (interp e2 env)))
       (case op
         ((+) (+ v1 v2))
         ((-) (- v1 v2))
         ((*) (* v1 v2))
         ((=) (= v1 v2)))))
    ((,rator . ,rand*)
     (let* ((closure.arg* (interp* exp env))
            (closure (car closure.arg*))
            (arg* (cdr closure.arg*)))
       (apply-closure closure arg*)))))
(define (interp* exp* env)
  (if (null? exp*)
      '()
      (let* ((exp (car exp*))
             (exp* (cdr exp*))
             (val (interp exp env))
             (val* (interp* exp* env)))
        (cons val val*))))
(define (decompose binding*)
  (if (null? binding*)
      (values '() '() '())
      (let ((binding (car binding*))
            (binding* (cdr binding*)))
        (let-values (((f* x** fbody*) (decompose binding*)))
          (match binding
            ((,f (lambda ,x* ,fbody))
             (values (cons f f*)
                     (cons x* x**)
                     (cons fbody fbody*))))))))
(define (extend-env* var* val* env)
  (append (map cons var* val*) env))
(define (extend-env-rec f* x** fbody* env)
  (let* ((closure*
          (map (lambda (x* fbody) (make-closure x* fbody 'foo)) x** fbody*))
         (env^ (extend-env* f* closure* env)))
    (for-each (lambda (closure)
                (set-closure-env! closure env^))
              closure*)
    env^))
(define (make-closure x* body env)
  (vector 'closure x* body env))
(define (closure-x* closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (set-closure-env! closure env)
  (vector-set! closure 3 env))
(define (apply-closure closure arg*)
  (let* ((x* (closure-x* closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (interp body (extend-env* x* arg* env))))
;> (interp '(letrec ((even? (lambda (n)
;                             (if (= n 0)
;                                 #t
;                                 (odd? (- n 1)))))
;                    (odd? (lambda (n)
;                            (if (= n 0)
;                                #f
;                                (even? (- n 1))))))
;             (even? 88))
;          (empty-env))
;#t