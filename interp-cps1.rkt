#lang racket
(require "match.rkt" "env0.rkt")
;<exp> ::= <var>
;       |  (lambda <var> <exp>)
;       |  (<exp> <exp>)
(define (interp exp env k)
  (match exp
    (,var
     (guard (symbol? var))
     (apply-k k (apply-env env var)))
    ((lambda ,x ,body)
     (apply-k k (make-closure x body env)))
    ((,rator ,rand)
     (interp rator env (rator-k rand env k)))))
(define (make-closure formal body env)
  (vector 'closure formal body env))
(define (closure-formal closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (apply-closure closure arg k)
  (let* ((formal (closure-formal closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (interp body (extend-env formal arg env) k)))
(define (empty-k) '(empty-k))
(define (rator-k rand env k)
  `(rator-k ,rand ,env ,k))
(define (rand-k closure k)
  `(rand-k ,closure ,k))
(define (apply-k k v)
  (match k
    ((rator-k ,rand ,env ,k)
     (interp rand env (rand-k v k)))
    ((rand-k ,closure ,k)
     (apply-closure closure v k))
    ((empty-k) v)))