#lang racket
(require "match.rkt" "env0.rkt" "truep.rkt")
;<exp> ::= <int>
;       |  <bool>
;       |  <var>
;       |  (if <exp> <exp> <exp>)
;       |  (lambda <var> <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (call/cc <exp>)
;       |  (throw <exp> <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>)
;<op> ::= + | - | * | =
(define (interp exp env k)
  (match exp
    (,int
     (guard (integer? int))
     (apply-k k int))
    (,bool
     (guard (boolean? bool))
     (apply-k k bool))
    (,var
     (guard (symbol? var))
     (apply-k k (apply-env env var)))
    ((if ,e1 ,e2 ,e3)
     (interp e1 env (if-k e2 e3 env k)))
    ((lambda ,x ,body)
     (apply-k k (make-closure x body env)))
    ((let ,x ,e ,body)
     (interp e env (let-k x env body k)))
    ((call/cc ,e)
     (interp e env (call/cc-k k)))
    ((throw ,e1 ,e2)
     (interp e1 env (throw-k-1 e2 env k)))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * =)))
     (interp e1 env (op-k-1 op e2 env k)))
    ((,rator ,rand)
     (interp rator env (rator-k rand env k)))))
(define (make-closure formal body env)
  (vector 'closure formal body env))
(define (closure-formal closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (apply-closure closure arg k)
  (let* ((formal (closure-formal closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (interp body (extend-env formal arg env) k)))
(define (apply-k k v)
  (match k
    ((if-k ,e2 ,e3 ,env ,k)
     (if (true? v)
         (interp e2 env k)
         (interp e3 env k)))
    ((let-k ,x ,env ,body ,k)
     (interp body (extend-env x v env) k))
    ((call/cc-k ,k)
     (apply-closure v k k))
    ((throw-k-1 ,e2 ,env ,k)
     (interp e2 env (throw-k-2 v)))
    ((throw-k-2 ,k)
     (apply-k k v))
    ((op-k-1 ,op ,e2 ,env ,k)
     (interp e2 env (op-k-2 op v k)))
    ((op-k-2 ,op ,v1 ,k)
     (case op
       ((+) (apply-k k (+ v1 v)))
       ((-) (apply-k k (- v1 v)))
       ((*) (apply-k k (* v1 v)))
       ((=) (apply-k k (= v1 v)))))
    ((rator-k ,rand ,env ,k)
     (interp rand env (rand-k v k)))
    ((rand-k ,closure ,k)
     (apply-closure closure v k))
    ((empty-k) v)
    (,else (error 'apply-k "~s is not a continuation" k))))
(define (empty-k) '(empty-k))
(define (if-k e2 e3 env k)
  `(if-k ,e2 ,e3 ,env ,k))
(define (let-k x env body k)
  `(let-k ,x ,env ,body ,k))
(define (call/cc-k k)
  `(call/cc-k ,k))
(define (throw-k-1 e2 env k)
  `(throw-k-1 ,e2 ,env ,k))
(define (throw-k-2 k)
  `(throw-k-2 ,k))
(define (op-k-1 op e2 env k)
  `(op-k-1 ,op ,e2 ,env ,k))
(define (op-k-2 op v1 k)
  `(op-k-2 ,op ,v1 ,k))
(define (rator-k rand env k)
  `(rator-k ,rand ,env ,k))
(define (rand-k closure k)
  `(rand-k ,closure ,k))
;> (interp
;   '(+ 2 (call/cc
;          (lambda k
;            (+ 3 (throw k 1)))))
;   (empty-env)
;   (empty-k))
;3
;> (interp
;   '(+ 2 (call/cc
;          (lambda k
;            (+ 3 1))))
;   (empty-env)
;   (empty-k))
;6