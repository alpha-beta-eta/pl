#lang racket
(require "match.rkt" "env0.rkt")
(define counter
  (let ((x -1))
    (lambda ()
      (set! x (+ x 1))
      x)))
(define (fresh-id x)
  (string->symbol
   (format "~s.~s" x (counter))))
(define (set? lst)
  (cond ((null? lst) #t)
        ((memq (car lst) (cdr lst)) #f)
        (else (set? (cdr lst)))))
(define (map0 f l)
  (if (null? l)
      '()
      (let* ((a (car l))
             (d (cdr l))
             (fa (f a))
             (fd (map0 f d)))
        (cons fa fd))))
;<exp> ::= <int>
;       |  <bool>
;       |  <var>
;       |  (if <exp> <exp> <exp>)
;       |  (lambda (<var>*) <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (letrec ((<var> (lambda (<var>*) <exp>))*) <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>*)
;<op> ::= + | - | * | =
(define (alpha exp env)
  (match exp
    (,int (guard (integer? int)) int)
    (,bool (guard (boolean? bool)) bool)
    (,var (guard (symbol? var)) (apply-env env var))
    ((if ,e1 ,e2 ,e3)
     (let* ((e1^ (alpha e1 env))
            (e2^ (alpha e2 env))
            (e3^ (alpha e3 env)))
       `(if ,e1^ ,e2^ ,e3^)))
    ((lambda ,x* ,body)
     (unless (set? x*)
       (error 'alpha "lambda duplicated variables ~s" x*))
     (let* ((x^* (map0 fresh-id x*))
            (env^ (extend-env* x* x^* env))
            (body^ (alpha body env^)))
       `(lambda ,x^* ,body^)))
    ((let ,x ,e ,body)
     (let* ((x^ (fresh-id x))
            (env^ (extend-env x x^ env))
            (e^ (alpha e env))
            (body^ (alpha body env^)))
       `(let ,x^ ,e^ ,body^)))
    ((letrec ,binding* ,body)
     (let-values (((f* x** fbody*) (decompose binding*)))
       (unless (set? f*)
         (error 'alpha "letrec duplicated variables ~s" f*))
       (let* ((f^* (map0 fresh-id f*))
              (env^ (extend-env* f* f^* env))
              (e^* (map0 (lambda (e) (alpha e env^))
                         (map (lambda (x* fbody)
                                `(lambda ,x* ,fbody))
                              x** fbody*)))
              (body^ (alpha body env^)))
         (Letrec f^* e^* body^))))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * =)))
     (let* ((e1^ (alpha e1 env))
            (e2^ (alpha e2 env)))
       `(,op ,e1^ ,e2^)))
    ((,rator . ,rand*)
     (map0 (lambda (e) (alpha e env)) exp))))
(define (decompose binding*)
  (if (null? binding*)
      (values '() '() '())
      (let ((binding (car binding*))
            (binding* (cdr binding*)))
        (let-values (((f* x** fbody*) (decompose binding*)))
          (match binding
            ((,f (lambda ,x* ,fbody))
             (values (cons f f*)
                     (cons x* x**)
                     (cons fbody fbody*))))))))
(define (extend-env* var* val* env)
  (append (map cons var* val*) env))
(define (Letrec x* e* body)
  `(letrec ,(map list x* e*) ,body))
(define (cps exp k)
  (match exp
    (,int (guard (integer? int)) (apply-k k int))
    (,bool (guard (boolean? bool)) (apply-k k bool))
    (,var (guard (symbol? var)) (apply-k k var))
    ((if ,e1 ,e2 ,e3)
     (cps e1 (lambda (s)
               (if (or (eq? k id) (symbol? k))
                   (let* ((t1 (cps e2 k))
                          (t2 (cps e3 k)))
                     `(if ,s ,t1 ,t2))
                   (let* ((k-id (fresh-id 'k))
                          (k-exp (build-k k))
                          (t1 (cps e2 k-id))
                          (t2 (cps e3 k-id)))
                     `(let ,k-id ,k-exp
                        (if ,s ,t1 ,t2)))))))
    ((lambda ,x* ,body) (apply-k k (cps-lambda x* body)))
    ((let ,x ,e ,body)
     (cps e (lambda (s)
              (let ((tail (cps body k)))
                `(let ,x ,s ,tail)))))
    ((letrec ,binding* ,body)
     (let-values (((f* x** fbody*) (decompose binding*)))
       (let* ((e* (cps-lambda* x** fbody*))
              (tail (cps body k)))
         (Letrec f* e* tail))))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * =)))
     (cps e1 (lambda (s1)
               (cps e2 (lambda (s2)
                         (apply-k k `(,op ,s1 ,s2)))))))
    ((,rator . ,rand*)
     (cps* exp (lambda (s*)
                 (attach s* (build-k k)))))))
(define (cps* exp* k)
  (if (null? exp*)
      (k '())
      (cps (car exp*)
           (lambda (s)
             (cps* (cdr exp*)
                   (lambda (s*)
                     (k (cons s s*))))))))
(define (cps-lambda x* body)
  (let* ((k-id (fresh-id 'k))
         (y* (attach x* k-id))
         (tail (cps body k-id)))
    `(lambda ,y* ,tail)))
(define (cps-lambda* x** fbody*)
  (let iter ((e* '()) (x** x**) (fbody* fbody*))
    (if (null? x**)
        (reverse e*)
        (let ((x* (car x**))
              (x** (cdr x**))
              (fbody (car fbody*))
              (fbody* (cdr fbody*)))
          (iter (cons (cps-lambda x* fbody) e*)
                x** fbody*)))))
(define id (lambda (x) x))
(define (apply-k k s)
  (if (symbol? k) `(,k ,s) (k s)))
(define (build-k k)
  (if (symbol? k)
      k
      (let* ((v-id (fresh-id 'v))
             (tail (k v-id)))
        `(lambda (,v-id) ,tail))))
(define (attach lst x)
  (append lst (list x)))
(define (CPS exp)
  (cps (alpha exp (empty-env)) id))
;<exp> ::= <tail>
;<simple> ::= <int>
;          |  <bool>
;          |  <var>
;          |  (lambda (<var>*) <tail>)
;          |  (<op> <simple> <simple>)
;<tail> ::= <simple>
;        |  (if <simple> <tail> <tail>)
;        |  (let <var> <simple> <tail>)
;        |  (letrec ((<var> (lambda (<var>*) <tail>))*) <tail>)
;        |  (<simple> <simple>*)
;<op> ::= + | - | * | =
;> (CPS '(letrec ((fact (lambda (n)
;                         (if (= n 0)
;                             1
;                             (* n (fact (- n 1)))))))
;          (fact 10)))
;'(letrec ((fact.0
;           (lambda (n.1 k.2)
;             (if (= n.1 0) (k.2 1) (fact.0 (- n.1 1) (lambda (v.3) (k.2 (* n.1 v.3))))))))
;   (fact.0 10 (lambda (v.4) v.4)))
;> (CPS '(letrec ((fib (lambda (n)
;                        (if (= n 0)
;                            0
;                            (if (= n 1)
;                                1
;                                (+ (fib (- n 1))
;                                   (fib (- n 2))))))))
;          (fib 10)))
;'(letrec ((fib.0
;           (lambda (n.1 k.2)
;             (if (= n.1 0)
;               (k.2 0)
;               (if (= n.1 1)
;                 (k.2 1)
;                 (fib.0 (- n.1 1) (lambda (v.3) (fib.0 (- n.1 2) (lambda (v.4) (k.2 (+ v.3 v.4)))))))))))
;   (fib.0 10 (lambda (v.5) v.5)))
;> (CPS '(letrec ((even? (lambda (n)
;                          (if (= n 0)
;                              #t
;                              (odd? (- n 1)))))
;                 (odd? (lambda (n)
;                         (if (= n 0)
;                             #f
;                             (even? (- n 1))))))
;          (even? 88)))
;'(letrec ((even?.0 (lambda (n.2 k.4) (if (= n.2 0) (k.4 #t) (odd?.1 (- n.2 1) k.4))))
;          (odd?.1 (lambda (n.3 k.5) (if (= n.3 0) (k.5 #f) (even?.0 (- n.3 1) k.5)))))
;   (even?.0 88 (lambda (v.6) v.6)))
;> (CPS '(lambda (f)
;          (lambda (g)
;            (lambda (h)
;              (lambda (x)
;                (f (g x) (h x)))))))
;'(lambda (f.0 k.4)
;   (k.4
;    (lambda (g.1 k.5)
;      (k.5
;       (lambda (h.2 k.6)
;         (k.6 (lambda (x.3 k.7) (g.1 x.3 (lambda (v.8) (h.2 x.3 (lambda (v.9) (f.0 v.8 v.9 k.7))))))))))))
;> (CPS '((lambda (x) (x x)) (lambda (x) (x x))))
;'((lambda (x.0 k.2) (x.0 x.0 k.2)) (lambda (x.1 k.3) (x.1 x.1 k.3)) (lambda (v.4) v.4))
;> (CPS '(let square (lambda (x) (* x x))
;          (+ (square 3) (square 4))))
;'(let square.0 (lambda (x.1 k.2) (k.2 (* x.1 x.1)))
;   (square.0 3 (lambda (v.3) (square.0 4 (lambda (v.4) (+ v.3 v.4))))))