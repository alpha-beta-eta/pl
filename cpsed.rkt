#lang racket
(require "match.rkt" "env0.rkt" "truep.rkt")
;<exp> ::= <tail>
;<simple> ::= <int>
;          |  <bool>
;          |  <var>
;          |  (lambda (<var>*) <tail>)
;          |  (<op> <simple> <simple>)
;<tail> ::= <simple>
;        |  (if <simple> <tail> <tail>)
;        |  (let <var> <simple> <tail>)
;        |  (letrec ((<var> (lambda (<var>*) <tail>))*) <tail>)
;        |  (<simple> <simple>*)
;<op> ::= + | - | * | =
(define (interp exp env)
  (Tail exp env))
(define (Simple simple env)
  (match simple
    (,int (guard (integer? int)) int)
    (,bool (guard (boolean? bool)) bool)
    (,var (guard (symbol? var)) (apply-env env var))
    ((lambda ,x* ,tail) (make-closure x* tail env))
    ((,op ,simple1 ,simple2)
     (guard (memq op '(+ - * =)))
     (let* ((v1 (Simple simple1 env))
            (v2 (Simple simple2 env)))
       (case op
         ((+) (+ v1 v2))
         ((-) (- v1 v2))
         ((*) (* v1 v2))
         ((=) (= v1 v2)))))))
(define (Tail tail env)
  (match tail
    (,simple (guard (simple? simple)) (Simple simple env))
    ((if ,simple ,tail1 ,tail2)
     (let ((v1 (Simple simple env)))
       (if (true? v1)
           (Tail tail1 env)
           (Tail tail2 env))))
    ((let ,x ,simple ,tail)
     (let* ((v (Simple simple env))
            (env^ (extend-env x v env)))
       (Tail tail env^)))
    ((letrec ,binding* ,tail)
     (let-values (((f* x** fbody*) (decompose binding*)))
       (Tail tail (extend-env-rec f* x** fbody* env))))
    ((,rator . ,rand*)
     (let* ((closure.arg* (Simple* tail env))
            (closure (car closure.arg*))
            (arg* (cdr closure.arg*)))
       (apply-closure closure arg*)))))
(define (simple? tail)
  (match tail
    (,int (guard (integer? int)) #t)
    (,bool (guard (boolean? bool)) #t)
    (,var (guard (symbol? var)) #t)
    ((lambda ,x* ,tail) #t)
    ((,op ,simple1 ,simple2) (guard (memq op '(+ - * =))) #t)
    (,else #f)))
(define (Simple* simple* env)
  (if (null? simple*)
      '()
      (let* ((simple (car simple*))
             (simple* (cdr simple*))
             (val (Simple simple env))
             (val* (Simple* simple* env)))
        (cons val val*))))
(define (decompose binding*)
  (if (null? binding*)
      (values '() '() '())
      (let ((binding (car binding*))
            (binding* (cdr binding*)))
        (let-values (((f* x** fbody*) (decompose binding*)))
          (match binding
            ((,f (lambda ,x* ,fbody))
             (values (cons f f*)
                     (cons x* x**)
                     (cons fbody fbody*))))))))
(define (extend-env* var* val* env)
  (append (map cons var* val*) env))
(define (extend-env-rec f* x** fbody* env)
  (let* ((closure*
          (map (lambda (x* fbody) (make-closure x* fbody 'foo)) x** fbody*))
         (env^ (extend-env* f* closure* env)))
    (for-each (lambda (closure)
                (set-closure-env! closure env^))
              closure*)
    env^))
(define (make-closure x* body env)
  (vector 'closure x* body env))
(define (closure-x* closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (set-closure-env! closure env)
  (vector-set! closure 3 env))
(define (apply-closure closure arg*)
  (let* ((x* (closure-x* closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (Tail body (extend-env* x* arg* env))))