#lang racket
(require "match.rkt" "env0.rkt" "store.rkt" "truep.rkt")
(define store0 (make-store 10000))
(define (newref val)
  (store0 'newref val))
(define (deref ref)
  (store0 'deref ref))
(define (setref ref val)
  (store0 'setref ref val))
;<exp> ::= <int>
;       |  <bool>
;       |  <var>
;       |  (if <exp> <exp> <exp>)
;       |  (lambda <var> <exp>)
;       |  (let <var> <exp> <exp>)
;       |  (begin <exp>+)
;       |  (newref <exp>)
;       |  (deref <exp>)
;       |  (setref <exp> <exp>)
;       |  (<op> <exp> <exp>)
;       |  (<exp> <exp>)
;<op> ::= + | - | * | =
(define (interp exp env)
  (match exp
    (,int (guard (integer? int)) int)
    (,bool (guard (boolean? bool)) bool)
    (,var (guard (symbol? var)) (apply-env env var))
    ((if ,e1 ,e2 ,e3)
     (let ((v1 (interp e1 env)))
       (if (true? v1)
           (interp e2 env)
           (interp e3 env))))
    ((lambda ,x ,body)
     (make-closure x body env))
    ((let ,x ,e ,body)
     (let* ((v (interp e env))
            (env^ (extend-env x v env)))
       (interp body env^)))
    ((begin . ,e+)
     (interp-e+ e+ env))
    ((newref ,e)
     (let ((val (interp e env)))
       (newref val)))
    ((deref ,e)
     (let ((ref (interp e env)))
       (deref ref)))
    ((setref ,e1 ,e2)
     (let* ((ref (interp e1 env))
            (val (interp e2 env)))
       (setref ref val)))
    ((,op ,e1 ,e2)
     (guard (memq op '(+ - * =)))
     (let* ((v1 (interp e1 env))
            (v2 (interp e2 env)))
       (case op
         ((+) (+ v1 v2))
         ((-) (- v1 v2))
         ((*) (* v1 v2))
         ((=) (= v1 v2)))))
    ((,rator ,rand)
     (let* ((closure (interp rator env))
            (arg (interp rand env)))
       (apply-closure closure arg)))))
(define (interp-e+ e+ env)
  (if (null? e+)
      (error 'interp-e+ "the body of a begin should not be empty")
      (let iter ((e (car e+)) (e* (cdr e+)))
        (if (null? e*)
            (interp e env)
            (begin (interp e env)
                   (iter (car e*) (cdr e*)))))))
(define (make-closure formal body env)
  (vector 'closure formal body env))
(define (closure-formal closure)
  (vector-ref closure 1))
(define (closure-body closure)
  (vector-ref closure 2))
(define (closure-env closure)
  (vector-ref closure 3))
(define (apply-closure closure arg)
  (let* ((formal (closure-formal closure))
         (body (closure-body closure))
         (env (closure-env closure)))
    (interp body (extend-env formal arg env))))
;> (interp
;   '(let fact-ref (newref 0)
;      (begin
;        (setref fact-ref
;                (lambda n
;                  (if (= n 0)
;                      1
;                      (* n ((deref fact-ref) (- n 1))))))
;        ((deref fact-ref) 10)))
;   (empty-env))
;3628800
;> (interp '(let counter (let x (newref 0)
;                          (lambda _
;                            (begin
;                              (setref x (+ (deref x) 1))
;                              (deref x))))
;             (begin (counter 0)
;                    (counter 0)
;                    (counter 0)))
;          (empty-env))
;3
;> (interp
;   '(let x (newref (newref 0))
;      (begin
;        (setref (deref x) 42)
;        (deref (deref x))))
;   (empty-env))
;42
;> (interp '(let swap (lambda ra
;                       (lambda rb
;                         (let t (deref ra)
;                           (begin (setref ra (deref rb))
;                                  (setref rb t)))))
;             (let rx (newref 0)
;               (let ry (newref 1)
;                 (begin ((swap rx) ry)
;                        (deref rx)))))
;          (empty-env))
;1